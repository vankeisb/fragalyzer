{"version":3,"sources":["Parser.ts","DrawPositions.ts","App.tsx","reportWebVitals.ts","index.tsx"],"names":["parseDemo","file","Promise","resolve","reject","arrayBuffer","then","players","buffer","Buffer","from","demoFile","DemoFile","nbTicks","start","Date","getTime","positions","Map","matchStarted","on","tick","entities","length","forEach","player","isFakePlayer","isAlive","p","pos","position","x","y","pps","get","name","undefined","set","fp","push","rounds","winner","gameEvents","e","console","log","dfps","filter","teamNumber","map","team","clanName","toString","roundStartTick","currentTick","teams","terrorists","cts","teamName","score","startTick","endTick","scoreCT","clanCT","scoreT","clanT","gameRules","roundsPlayed","error","res","tickRate","parse","filterPositions","selectedPlayers","selectedTicks","newPos","has","find","tr","getTeams","parseResult","s","Set","add","Array","sort","getPlayersInTeam","a","b","localeCompare","getPlayerNames","normalize","srcMin","srcMax","srcValue","targetMax","colors","unknownColor","getPlayerColor","i","indexOf","c","colorToString","alpha","drawPositions","canvas","selectedRounds","ctx","getContext","Error","clearRect","width","height","allPlayers","rect","getBoundingClientRect","Math","min","normalizedPositions","minX","maxX","minY","maxY","entries","playerPos","max","playerName","playerPositions","pp","normalizePositions","tickRanges","r","index","fillStyle","fillRect","windowResized","tag","gotCanvasDimensions","init","noCmd","state","nothing","canvasId","canvasWrapperId","getCanvasDimensions","Task","fromLambda","document","getElementById","dim","view","dispatch","model","className","message","withDefaultSupply","onDragOver","preventDefault","onDropCapture","msg","dataTransfer","files","f","item","just","canvasDimensions","id","h","w","teamPlayers","style","backgroundColor","type","checked","onChange","viewTimeline","update","attempt","match","ifReady","newModel","draw","err","t","fromPromise","Dim","zero","spa","setState","newSelRounds","drawIntoCanvas","Cmd","none","windowEvents","WindowEvents","subscriptions","round","selected","onClick","App","devTools","DevTools","window","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.208ae38e.chunk.js","sourcesContent":["import {pos, Pos} from \"tea-pop-core\";\nimport {DemoFile} from \"demofile\";\n\n\nexport type Positions = Map<string, FPos[]>;\n\nexport interface FPos {\n  readonly p: Pos;\n  readonly tick: number;\n}\n\nexport interface FPlayer {\n  readonly name: string;\n  readonly clanName: string;\n}\n\nexport interface FRound {\n  readonly startTick: number;\n  readonly endTick: number;\n  readonly winner: number;\n  readonly clanT: string;\n  readonly scoreT: number;\n  readonly clanCT: string;\n  readonly scoreCT: number;\n}\n\nexport interface ParseResult {\n  readonly positions: Positions;\n  readonly players: ReadonlyArray<FPlayer>;\n  readonly rounds: ReadonlyArray<FRound>;\n  readonly tickRate: number;\n}\n\nexport function parseDemo(file: File): Promise<ParseResult> {\n  return new Promise<ParseResult>((resolve, reject) => {\n    file.arrayBuffer().then(arrayBuffer => {\n\n      const buffer = Buffer.from(arrayBuffer);\n\n      const demoFile = new DemoFile();\n\n      let nbTicks = 0;\n      let start = new Date().getTime();\n\n      const positions = new Map<string, FPos[]>();\n\n      let matchStarted = false;\n\n      demoFile.on(\"tickend\", tick => {\n        // console.log(\"tick\", nbTicks, tick);\n        nbTicks++;\n        if (!matchStarted) {\n          return;\n        }\n        const players = demoFile.entities.players;\n        if (players && players.length > 0) {\n          players.forEach(player => {\n            if (player && !player.isFakePlayer && player.isAlive) {\n              const p = pos(player.position.x, player.position.y);\n              let pps = positions.get(player.name);\n              if (pps === undefined) {\n                pps = []\n                positions.set(player.name, pps);\n              }\n              const fp: FPos = {\n                p,\n                tick,\n              }\n              pps.push(fp)\n            }\n          })\n        }\n      })\n\n      let players: FPlayer[];\n      const rounds: FRound[] = [];\n      let winner: number = 0;\n\n      demoFile.gameEvents.on('begin_new_match', e => {\n        console.log(\"begin match\");\n        if (players === undefined) {\n          matchStarted = true;\n          players = [];\n          const dfps = demoFile.players;\n          players = dfps.filter(p => !p.isFakePlayer && p.teamNumber >= 2).map(p => {\n            const team = p.team;\n            return {\n              name: p.name,\n              clanName: team?.clanName || p.teamNumber.toString(),\n            };\n          });\n          console.log(\"players\", players);\n        }\n      })\n\n      let roundStartTick: number = 0;\n\n      demoFile.gameEvents.on(\"round_start\", () => {\n        console.log(\"round start\");\n        roundStartTick = demoFile.currentTick;\n      })\n\n      demoFile.gameEvents.on(\"round_end\", e => {\n        console.log(\"round end\", e.winner)\n        winner = e.winner;\n      })\n\n      demoFile.gameEvents.on('round_officially_ended', e => {\n        console.log(\"round officially ended\");\n        const teams = demoFile.teams;\n\n        const terrorists = teams[2];\n        const cts = teams[3];\n\n        console.log(\n            \"\\t%s: %s score %d\\n\\t%s: %s score %d\",\n            terrorists.teamName,\n            terrorists.clanName,\n            terrorists.score,\n            cts.teamName,\n            cts.clanName,\n            cts.score\n        );\n        rounds.push({\n          startTick: roundStartTick,\n          endTick: demoFile.currentTick,\n          winner,\n          scoreCT: cts.score,\n          clanCT: cts.clanName,\n          scoreT: terrorists.score,\n          clanT: terrorists.clanName,\n        })\n      })\n\n      demoFile.gameEvents.on('round_start', e => {\n        winner = 0;\n        console.log(\"round start\", demoFile.gameRules.roundsPlayed)\n        // rounds.push({\n        //   index: demoFile.gameRules.roundsPlayed\n        // })\n      })\n\n      // demoFile.userMessages.on('EndOfMatchAllPlayersData', e => {\n      //   debugger;\n      //   e.allplayerdata.forEach(playerData => {\n      //     console.log(playerData.playercolor);\n      //   })\n      // });\n\n      demoFile.on(\"end\", e => {\n        console.log(\"done, ticks =\", nbTicks, \"elapsed =\", new Date().getTime() - start);\n        console.log(\"Finished.\");\n        if (e.error) {\n          console.error(\"Error during parsing:\", e.error);\n          reject(e)\n        } else {\n          const res: ParseResult = {\n            positions,\n            players,\n            rounds,\n            tickRate: demoFile.tickRate,\n          };\n          console.log(\"parsed\", res);\n          resolve(res);\n        }\n      });\n\n      // Start parsing the buffer now that we've added our event listeners\n      demoFile.parse(buffer);\n    });\n  });\n}\n\nexport type TickRange = [startTick: number, endTick: number];\n\nexport function filterPositions(positions: Positions, selectedPlayers: ReadonlySet<string>, selectedTicks: ReadonlyArray<TickRange>): Positions {\n  const newPos: Positions = new Map();\n  positions.forEach((pps, player) => {\n    if (selectedPlayers.has(player)) {\n      newPos.set(player, pps.filter(p => {\n        const matchingTr = selectedTicks.find(tr => p.tick >= tr[0] && p.tick <= tr[1]);\n        return matchingTr !== undefined;\n      }));\n    }\n  })\n  return newPos;\n}\n\nexport function getTeams(parseResult: ParseResult): ReadonlyArray<string> {\n  const s = new Set<string>();\n  parseResult.players.forEach(player => {\n    s.add(player.clanName);\n  })\n  return Array.from(s).sort();\n}\n\nexport function getPlayersInTeam(parseResult: ParseResult, team: string): ReadonlyArray<FPlayer> {\n  const res = new Array<FPlayer>();\n  parseResult.players.forEach(p => {\n    if (p.clanName === team) {\n      res.push(p);\n    }\n  })\n  return res.sort((a, b) => a.name.localeCompare(b.name));\n}\n\nexport function getPlayerNames(parseResult: ParseResult): ReadonlyArray<string> {\n  return parseResult.players.map(p => p.name).sort();\n}\n","import {pos} from \"tea-pop-core\";\nimport {filterPositions, FPos, getPlayerNames, ParseResult, Positions, TickRange} from \"./Parser\";\n\nexport function normalize(srcMin: number, srcMax: number, srcValue: number, targetMax: number): number {\n  const srcLen = srcMax - srcMin;\n  const translateX = -srcMin;\n  const scaleFactor = srcLen / targetMax;\n  const translatedValue = srcValue + translateX;\n  return translatedValue / scaleFactor;\n}\n\nexport function normalizePositions(targetMax: number, positions: Positions): Positions {\n  let minX = 0;\n  let maxX = 0;\n  let minY = 0;\n  let maxY = 0;\n  // first loop, to get min/max values\n  for (let p of positions.entries()) {\n    for (let playerPos of p[1]) {\n      minX = Math.min(playerPos.p.x, minX);\n      maxX = Math.max(playerPos.p.x, maxX);\n      minY = Math.min(playerPos.p.y, minY);\n      maxY = Math.max(playerPos.p.y, maxY);\n    }\n  }\n\n  const res: Positions = new Map<string, FPos[]>();\n  // loop again and recreate map with normalized positions\n  for (let [playerName, playerPositions] of positions.entries()) {\n    res.set(playerName, playerPositions.map(pp => ({\n      p: pos(\n          normalize(minX, maxX, pp.p.x, targetMax),\n          normalize(minY, maxY, pp.p.y, targetMax),\n      ),\n      tick: pp.tick,\n    })));\n  }\n  return res;\n}\n\nexport type Color = [r:number, g:number, b: number];\n\nconst colors: ReadonlyArray<Color> = [\n  [0, 140, 255],\n  [255, 140, 255],\n  [255, 0, 255],\n  [255, 0, 0],\n  [255, 132, 97],\n  [0, 183, 32],\n  [238, 183, 32],\n  [10, 183, 164],\n  [198, 197, 0],\n  [42, 197, 255],\n  [221, 91, 90]\n];\n\nconst unknownColor: Color = [0, 0, 0];\n\nexport function getPlayerColor(players: ReadonlyArray<string>, player: string): [r:number, g:number, b: number] {\n  const i = players.indexOf(player);\n  if (i === -1) {\n    return unknownColor;\n  }\n  const c = colors[i];\n  return c ?? unknownColor;\n}\n\nexport function colorToString(c: Color, alpha: number): string {\n  return `rgba(${c[0]},${c[1]},${c[2]},${alpha})`;\n}\n\nexport function drawPositions(canvas: HTMLCanvasElement, parseResult: ParseResult, selectedPlayers: ReadonlySet<string>, selectedRounds: ReadonlySet<number>) {\n  const ctx = canvas.getContext('2d');\n  if (!ctx) {\n    throw new Error(\"no context\");\n  }\n\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n  const { positions } = parseResult;\n  const allPlayers = getPlayerNames(parseResult);\n  const rect = canvas.getBoundingClientRect();\n  const targetMax = Math.min(rect.height, rect.width);\n  const normalizedPositions = normalizePositions(targetMax, positions);\n  const tickRanges: ReadonlyArray<TickRange> = parseResult.rounds\n      .filter((r, index) => selectedRounds.has(index))\n      .map(r => [r.startTick, r.endTick]);\n  const alpha = 0.1 * parseResult.tickRate / 64;\n  for (let [playerName, pps] of filterPositions(normalizedPositions, selectedPlayers, tickRanges).entries()) {\n    ctx.fillStyle = colorToString(getPlayerColor(allPlayers, playerName), alpha);\n    for (let pp of pps) {\n      ctx.fillRect(pp.p.x, targetMax - pp.p.y, 2, 2);\n    }\n  }\n}\n","import React from 'react';\nimport './App.scss';\nimport {Cmd, Dispatcher, just, Maybe, noCmd, nothing, Result, Sub, Task} from \"tea-cup-core\";\nimport {DevTools, Program, WindowEvents} from \"react-tea-cup\";\nimport {dim, Dim} from \"tea-pop-core\";\nimport {colorToString, drawPositions, getPlayerColor} from \"./DrawPositions\";\nimport {getPlayerNames, getPlayersInTeam, getTeams, parseDemo, ParseResult} from \"./Parser\";\n\ninterface Model {\n  readonly state: State;\n  readonly error: Maybe<Error>;\n}\n\ntype State =\n    | { tag: 'fresh' }\n    | { tag: 'parsing' }\n    | ReadyState\n\ninterface ReadyState {\n  tag: 'ready';\n  readonly canvasDimensions: Dim;\n  readonly parseResult: ParseResult;\n  readonly selectedPlayers: ReadonlySet<string>;\n  readonly selectedRounds: ReadonlySet<number>;\n}\n\ntype Msg =\n  | { tag: 'window-resized' }\n  | { tag: 'got-canvas-dimensions', r: Result<Error, Dim> }\n  | { tag: 'file-dropped', file: Maybe<File> }\n  | { tag: 'got-parse-result', r: Result<Error, ParseResult> }\n  | { tag: 'got-draw-result', r: Result<Error, ParseResult> }\n  | { tag: 'toggle-player', player: string }\n  | { tag: 'toggle-round', index: number }\n\nconst windowResized: Msg = { tag: 'window-resized'}\n\nfunction gotCanvasDimensions(r: Result<Error,Dim>): Msg {\n  return { tag: \"got-canvas-dimensions\", r };\n}\n\nfunction init(): [Model, Cmd<Msg>] {\n  return noCmd(\n      {\n        state: { tag: \"fresh\" },\n        error: nothing,\n      }\n  );\n}\n\nconst canvasId = \"csgo-canvas\";\nconst canvasWrapperId = \"canvas-wrapper\";\n\nconst getCanvasDimensions: Task<Error, Dim> = Task.fromLambda(() => {\n  const c = document.getElementById(canvasWrapperId);\n  if (!c) {\n    throw new Error(\"canvas wrapper not found\");\n  }\n  const r = c.getBoundingClientRect();\n  return dim(r.width, r.height);\n})\n\nfunction view(dispatch: Dispatcher<Msg>, model: Model) {\n  return model.error\n    .map(e => (\n        <div className=\"fragalyzer error\">\n          <h1>Oooops</h1>\n          <pre>{e.message}</pre>\n        </div>\n    ))\n    .withDefaultSupply(() => {\n      const { state } = model;\n      switch (state.tag) {\n        case \"fresh\": {\n          return (\n              <div\n                  className=\"fragalyzer home\"\n                  onDragOver={(e) => {\n                    e.preventDefault();\n                  }}\n                  onDropCapture={e => {\n                    e.preventDefault();\n                    const msg: Msg = {\n                      tag: 'file-dropped',\n                      file: nothing\n                    };\n                    if (e.dataTransfer.files.length === 1) {\n                      const f = e.dataTransfer.files.item(0);\n                      if (f) {\n                        dispatch({\n                          ...msg,\n                          file: just(f)\n                        })\n                      } else {\n                        dispatch(msg)\n                      }\n                    } else {\n                      dispatch(msg);\n                    }\n                  }}\n              >\n                Drop a demo here !\n              </div>\n          )\n        }\n        case \"parsing\": {\n          return <div className=\"fragalyzer parsing\"><p>Parsing, plz wait...</p></div>\n        }\n        case \"ready\": {\n          const { parseResult, canvasDimensions } = state;\n          // const size = Math.min(canvasDimensions.w, canvasDimensions.h);\n          return (\n              <div className=\"fragalyzer ready\">\n                <div className=\"main\">\n                  <div id={canvasWrapperId} className=\"map-view\">\n                    {/*<div className=\"map-image\">*/}\n                    {/*  <img*/}\n                    {/*      height={size}*/}\n                    {/*      width={size}*/}\n                    {/*      src=\"./maps/mirage.png\"*/}\n                    {/*  />*/}\n                    {/*</div>*/}\n                    <canvas\n                        height={canvasDimensions.h}\n                        width={canvasDimensions.w}\n                        id={canvasId}\n                    />\n                  </div>\n                  <div className=\"right-panel\">\n                    {getTeams(parseResult).map(team => {\n                      const teamPlayers = getPlayersInTeam(parseResult, team).map(p => p.name);\n                      const allPlayers = getPlayerNames(parseResult);\n                      return (\n                          <div key={team} className=\"team\">\n                            <h2 className=\"team\">{team}</h2>\n                            <ul>\n                              {teamPlayers.map(player =>\n                                  <li key={player}>\n                                    <div className=\"player-color\" style={{\n                                      backgroundColor: colorToString(getPlayerColor(allPlayers, player), 1.0)\n                                    }}/>\n                                    <input\n                                        type=\"checkbox\"\n                                        name={player}\n                                        checked={state.selectedPlayers.has(player)}\n                                        onChange={e => dispatch({tag: 'toggle-player', player: player})}\n                                    />\n                                    {player}\n                                  </li>\n                              )}\n                            </ul>\n                          </div>\n                      );\n                    })}\n                  </div>\n                </div>\n                {viewTimeline(dispatch, parseResult, state.selectedRounds)}\n              </div>\n          );\n        }\n      }\n    })\n}\n\nfunction update(msg: Msg, model: Model): [Model, Cmd<Msg>] {\n  switch (msg.tag) {\n    case \"window-resized\": {\n      if (model.state.tag === \"ready\") {\n        return [model, Task.attempt(getCanvasDimensions, gotCanvasDimensions)];\n      }\n      return noCmd(model);\n    }\n    case \"got-canvas-dimensions\": {\n      return msg.r.match(\n          canvasDimensions => {\n            return ifReady(model, state => {\n              const newModel: Model = {\n                ...model,\n                state: {\n                  ...state,\n                  canvasDimensions,\n                }\n              };\n              return [\n                newModel,\n                draw(newModel)\n              ]\n            });\n          },\n          err => noCmd({...model, error: just(err)})\n      )\n    }\n    case \"file-dropped\": {\n      return msg.file\n          .map<[Model, Cmd<Msg>]>(f => {\n            const newModel: Model = {\n              ...model,\n              state: {\n                tag: 'parsing'\n              }\n            };\n            const t: Task<Error, ParseResult> = Task.fromPromise(() =>\n              parseDemo(f)\n            );\n            const cmd: Cmd<Msg> =\n                Task.attempt(\n                    t,\n                  r => ({ tag: \"got-parse-result\", r })\n                )\n            return [newModel, cmd];\n          })\n          .withDefaultSupply(() => noCmd({\n            ...model,\n            state: {\n              tag: 'fresh'\n            }\n          }));\n    }\n    case \"got-parse-result\": {\n      return msg.r.match(\n          parseResult => {\n            const selectedPlayers: ReadonlySet<string> = new Set(parseResult.players.map(p => p.name));\n            const newModel: Model = {\n              ...model,\n              state: {\n                tag: \"ready\",\n                parseResult,\n                selectedPlayers,\n                canvasDimensions: Dim.zero,\n                selectedRounds: new Set(parseResult.rounds.map((r, index) => index)),\n              }\n            };\n            return [newModel, Task.attempt(getCanvasDimensions, gotCanvasDimensions)];\n          },\n          err => noCmd({...model, error: just(err)})\n      )\n\n\n    }\n    case \"got-draw-result\": {\n      console.log(\"draw res\");\n      return noCmd(model);\n    }\n    case \"toggle-player\": {\n      return ifReady(model, state => {\n        const { selectedPlayers } = state;\n        const spa: string[] = selectedPlayers.has(msg.player)\n            ? Array.from(selectedPlayers).filter(x => x !== msg.player)\n            : [...Array.from(selectedPlayers), msg.player];\n        const newModel: Model = setState(model, {\n          ...state,\n          selectedPlayers: new Set(spa)\n        });\n        return [newModel, draw(newModel)];\n      })\n    }\n    case \"toggle-round\": {\n      return ifReady(model, state => {\n        const { selectedRounds } = state;\n        const a = Array.from(selectedRounds);\n        const newSelRounds = new Set(\n            selectedRounds.has(msg.index)\n              ? a.filter(x => x !== msg.index)\n              : [...a, msg.index]\n        );\n        const newModel: Model = setState(model, {\n          ...state,\n          selectedRounds: newSelRounds\n        });\n        return [newModel, draw(newModel)];\n      })\n    }\n  }\n}\n\nfunction ifReady(model: Model, f:(state: ReadyState) => [Model, Cmd<Msg>]): [Model, Cmd<Msg>] {\n  if (model.state.tag === 'ready') {\n    return f(model.state);\n  }\n  return noCmd(model)\n}\n\nfunction setState(model: Model, state: State): Model {\n  return {\n    ...model, state\n  }\n}\n\nfunction draw(model: Model): Cmd<Msg> {\n  if (model.state.tag === \"ready\") {\n    const { selectedPlayers, parseResult, selectedRounds } = model.state;\n    return drawIntoCanvas(parseResult, selectedPlayers, selectedRounds)\n  }\n  return Cmd.none();\n}\n\nfunction drawIntoCanvas(parseResult: ParseResult, selectedPlayers: ReadonlySet<string>, selectedRounds: ReadonlySet<number>): Cmd<Msg> {\n  const t: Task<Error, ParseResult> = Task.fromLambda(() => {\n    const canvas = document.getElementById(canvasId) as HTMLCanvasElement;\n    if (!canvas) {\n      throw new Error(\"canvas not found !\");\n    }\n    drawPositions(canvas, parseResult, selectedPlayers, selectedRounds);\n    return parseResult;\n  });\n  return Task.attempt(t, r => ({\n    tag: 'got-draw-result',\n    r\n  }))\n}\n\nconst windowEvents = new WindowEvents();\n\nfunction subscriptions(model: Model): Sub<Msg> {\n  return windowEvents.on('resize', () => windowResized)\n}\n\n\nfunction viewTimeline(dispatch: Dispatcher<Msg>, parseResult: ParseResult, selectedRounds: ReadonlySet<number>) {\n  return (\n    <div className=\"timeline\">\n      {parseResult.rounds.map((round, index) => {\n        const selected = selectedRounds.has(index);\n        const className = `round${selected ? ' selected' : ''}`;\n        return (\n            <div\n                className={className}\n                key={index}\n                onClick={() => dispatch({tag: 'toggle-round', index})}\n            >\n              {index}\n            </div>\n        )\n      })}\n    </div>\n  );\n}\n\nfunction App() {\n  return (\n      <Program\n          init={init}\n          view={view}\n          update={update}\n          subscriptions={subscriptions}\n          devTools={DevTools.init<Model, Msg>(window)}\n      />\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}