{"version":3,"sources":["Parser.ts","DrawPositions.ts","App.tsx","reportWebVitals.ts","index.tsx"],"names":["teamToString","teamNumber","parseDemo","file","Promise","resolve","reject","arrayBuffer","then","players","buffer","Buffer","from","demoFile","DemoFile","nbTicks","start","Date","getTime","positions","Map","matchStarted","on","tick","entities","length","forEach","player","isFakePlayer","isAlive","p","pos","position","x","y","pps","get","name","undefined","set","fp","push","rounds","winner","gameEvents","e","console","log","dfps","filter","map","team","clanName","roundStartTick","currentTick","teams","terrorists","cts","teamName","score","startTick","endTick","scoreCT","clanCT","scoreT","clanT","gameRules","roundsPlayed","error","res","tickRate","mapName","header","parse","filterPositions","selectedPlayers","selectedTicks","newPos","has","find","tr","getTeams","parseResult","s","Set","add","Array","sort","getPlayersInTeam","a","b","localeCompare","getPlayerNames","normalize","srcMin","srcMax","srcValue","targetMax","colors","unknownColor","getPlayerColor","i","indexOf","c","colorToString","alpha","alphas","64","128","drawPositions","canvas","selectedRounds","ctx","getContext","Error","clearRect","width","height","allPlayers","rect","getBoundingClientRect","Math","min","normalizedPositions","minX","maxX","minY","maxY","entries","playerPos","max","playerName","playerPositions","pp","normalizePositions","tickRanges","r","index","fillStyle","fillRect","windowResized","tag","gotCanvasDimensions","init","noCmd","state","dragOver","nothing","canvasId","canvasWrapperId","getCanvasDimensions","Task","fromLambda","document","getElementById","dim","view","dispatch","model","className","message","withDefaultSupply","onDragOver","preventDefault","over","onDragLeave","onDropCapture","msg","dataTransfer","files","f","item","just","canvasDimensions","id","h","w","teamPlayers","style","backgroundColor","type","checked","onChange","viewTimeline","update","ifReady","attempt","match","newModel","draw","err","t","fromPromise","Dim","zero","spa","setState","newSelRounds","drawIntoCanvas","Cmd","none","windowEvents","WindowEvents","subscriptions","round","selected","onClick","App","devTools","DevTools","window","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.d33c335a.chunk.js","sourcesContent":["import {pos, Pos} from \"tea-pop-core\";\nimport {DemoFile, TeamNumber} from \"demofile\";\n\n\nexport type Positions = Map<string, FPos[]>;\n\nexport interface FPos {\n  readonly p: Pos;\n  readonly tick: number;\n}\n\nexport interface FPlayer {\n  readonly name: string;\n  readonly clanName: string;\n}\n\nexport interface FRound {\n  readonly startTick: number;\n  readonly endTick: number;\n  readonly winner: number;\n  readonly clanT: string;\n  readonly scoreT: number;\n  readonly clanCT: string;\n  readonly scoreCT: number;\n}\n\nexport interface ParseResult {\n  readonly positions: Positions;\n  readonly players: ReadonlyArray<FPlayer>;\n  readonly rounds: ReadonlyArray<FRound>;\n  readonly tickRate: number;\n  readonly mapName: string;\n}\n\nfunction teamToString(teamNumber: number): string {\n  switch (teamNumber) {\n    case 1: return \"Spectator\";\n    case 2: return \"Terrorists\";\n    case 3: return \"Counter Terrorists\";\n    default:\n      return \"Unknown-\" + teamNumber;\n  }\n}\n\nexport function parseDemo(file: File): Promise<ParseResult> {\n  return new Promise<ParseResult>((resolve, reject) => {\n    file.arrayBuffer().then(arrayBuffer => {\n\n      const buffer = Buffer.from(arrayBuffer);\n\n      const demoFile = new DemoFile();\n\n      let nbTicks = 0;\n      let start = new Date().getTime();\n\n      const positions = new Map<string, FPos[]>();\n\n      let matchStarted = false;\n\n      demoFile.on(\"tickend\", tick => {\n        // console.log(\"tick\", nbTicks, tick);\n        nbTicks++;\n        if (!matchStarted) {\n          return;\n        }\n        const players = demoFile.entities.players;\n        if (players && players.length > 0) {\n          players.forEach(player => {\n            if (player && !player.isFakePlayer && player.isAlive) {\n              const p = pos(player.position.x, player.position.y);\n              let pps = positions.get(player.name);\n              if (pps === undefined) {\n                pps = []\n                positions.set(player.name, pps);\n              }\n              const fp: FPos = {\n                p,\n                tick,\n              }\n              pps.push(fp)\n            }\n          })\n        }\n      })\n\n      let players: FPlayer[];\n      const rounds: FRound[] = [];\n      let winner: number = 0;\n\n      demoFile.gameEvents.on('begin_new_match', e => {\n        console.log(\"begin match\");\n        if (players === undefined) {\n          matchStarted = true;\n          players = [];\n          const dfps = demoFile.players;\n          players = dfps.filter(p => !p.isFakePlayer && p.teamNumber >= 2).map(p => {\n            const team = p.team;\n            return {\n              name: p.name,\n              clanName: team?.clanName || teamToString(p.teamNumber),\n            };\n          });\n          console.log(\"players\", players);\n        }\n      })\n\n      let roundStartTick: number = 0;\n\n      demoFile.gameEvents.on(\"round_start\", () => {\n        console.log(\"round start\");\n        roundStartTick = demoFile.currentTick;\n      })\n\n      demoFile.gameEvents.on(\"round_end\", e => {\n        console.log(\"round end\", e.winner)\n        winner = e.winner;\n      })\n\n      demoFile.gameEvents.on('round_officially_ended', e => {\n        console.log(\"round officially ended\");\n        const teams = demoFile.teams;\n\n        const terrorists = teams[2];\n        const cts = teams[3];\n\n        console.log(\n            \"\\t%s: %s score %d\\n\\t%s: %s score %d\",\n            terrorists.teamName,\n            terrorists.clanName,\n            terrorists.score,\n            cts.teamName,\n            cts.clanName,\n            cts.score\n        );\n        rounds.push({\n          startTick: roundStartTick,\n          endTick: demoFile.currentTick,\n          winner,\n          scoreCT: cts.score,\n          clanCT: cts.clanName,\n          scoreT: terrorists.score,\n          clanT: terrorists.clanName,\n        })\n      })\n\n      demoFile.gameEvents.on('round_start', e => {\n        winner = 0;\n        console.log(\"round start\", demoFile.gameRules.roundsPlayed)\n        // rounds.push({\n        //   index: demoFile.gameRules.roundsPlayed\n        // })\n      })\n\n      // demoFile.userMessages.on('EndOfMatchAllPlayersData', e => {\n      //   debugger;\n      //   e.allplayerdata.forEach(playerData => {\n      //     console.log(playerData.playercolor);\n      //   })\n      // });\n\n      demoFile.on(\"end\", e => {\n        console.log(\"done, ticks =\", nbTicks, \"elapsed =\", new Date().getTime() - start);\n        console.log(\"Finished.\");\n        if (e.error) {\n          console.error(\"Error during parsing:\", e.error);\n          reject(e)\n        } else {\n          const res: ParseResult = {\n            positions,\n            players,\n            rounds,\n            tickRate: demoFile.tickRate,\n            mapName: demoFile.header.mapName,\n          };\n          console.log(\"parsed\", res);\n          resolve(res);\n        }\n      });\n\n      // Start parsing the buffer now that we've added our event listeners\n      demoFile.parse(buffer);\n    });\n  });\n}\n\nexport type TickRange = [startTick: number, endTick: number];\n\nexport function filterPositions(positions: Positions, selectedPlayers: ReadonlySet<string>, selectedTicks: ReadonlyArray<TickRange>): Positions {\n  const newPos: Positions = new Map();\n  positions.forEach((pps, player) => {\n    if (selectedPlayers.has(player)) {\n      newPos.set(player, pps.filter(p => {\n        const matchingTr = selectedTicks.find(tr => p.tick >= tr[0] && p.tick <= tr[1]);\n        return matchingTr !== undefined;\n      }));\n    }\n  })\n  return newPos;\n}\n\nexport function getTeams(parseResult: ParseResult): ReadonlyArray<string> {\n  const s = new Set<string>();\n  parseResult.players.forEach(player => {\n    s.add(player.clanName);\n  })\n  return Array.from(s).sort();\n}\n\nexport function getPlayersInTeam(parseResult: ParseResult, team: string): ReadonlyArray<FPlayer> {\n  const res = new Array<FPlayer>();\n  parseResult.players.forEach(p => {\n    if (p.clanName === team) {\n      res.push(p);\n    }\n  })\n  return res.sort((a, b) => a.name.localeCompare(b.name));\n}\n\nexport function getPlayerNames(parseResult: ParseResult): ReadonlyArray<string> {\n  return parseResult.players.map(p => p.name).sort();\n}\n","import {pos} from \"tea-pop-core\";\nimport {filterPositions, FPos, getPlayerNames, ParseResult, Positions, TickRange} from \"./Parser\";\n\nexport function normalize(srcMin: number, srcMax: number, srcValue: number, targetMax: number): number {\n  const srcLen = srcMax - srcMin;\n  const translateX = -srcMin;\n  const scaleFactor = srcLen / targetMax;\n  const translatedValue = srcValue + translateX;\n  return translatedValue / scaleFactor;\n}\n\nexport function normalizePositions(targetMax: number, positions: Positions): Positions {\n  let minX = 0;\n  let maxX = 0;\n  let minY = 0;\n  let maxY = 0;\n  // first loop, to get min/max values\n  for (let p of positions.entries()) {\n    for (let playerPos of p[1]) {\n      minX = Math.min(playerPos.p.x, minX);\n      maxX = Math.max(playerPos.p.x, maxX);\n      minY = Math.min(playerPos.p.y, minY);\n      maxY = Math.max(playerPos.p.y, maxY);\n    }\n  }\n\n  const res: Positions = new Map<string, FPos[]>();\n  // loop again and recreate map with normalized positions\n  for (let [playerName, playerPositions] of positions.entries()) {\n    res.set(playerName, playerPositions.map(pp => ({\n      p: pos(\n          normalize(minX, maxX, pp.p.x, targetMax),\n          normalize(minY, maxY, pp.p.y, targetMax),\n      ),\n      tick: pp.tick,\n    })));\n  }\n  return res;\n}\n\nexport type Color = [r:number, g:number, b: number];\n\nconst colors: ReadonlyArray<Color> = [\n  [0, 140, 255],\n  [255, 140, 255],\n  [255, 0, 255],\n  [255, 0, 0],\n  [255, 132, 97],\n  [0, 183, 32],\n  [238, 183, 32],\n  [10, 183, 164],\n  [198, 197, 0],\n  [42, 197, 255],\n  [221, 91, 90]\n];\n\nconst unknownColor: Color = [0, 0, 0];\n\nexport function getPlayerColor(players: ReadonlyArray<string>, player: string): [r:number, g:number, b: number] {\n  const i = players.indexOf(player);\n  if (i === -1) {\n    return unknownColor;\n  }\n  const c = colors[i];\n  return c ?? unknownColor;\n}\n\nexport function colorToString(c: Color, alpha: number): string {\n  return `rgba(${c[0]},${c[1]},${c[2]},${alpha})`;\n}\n\nconst alphas: { [id: number]: number } = {\n  64: 0.2,\n  128: 0.1\n}\n\nexport function drawPositions(canvas: HTMLCanvasElement, parseResult: ParseResult, selectedPlayers: ReadonlySet<string>, selectedRounds: ReadonlySet<number>) {\n  const ctx = canvas.getContext('2d');\n  if (!ctx) {\n    throw new Error(\"no context\");\n  }\n\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n  const { positions } = parseResult;\n  const allPlayers = getPlayerNames(parseResult);\n  const rect = canvas.getBoundingClientRect();\n  const targetMax = Math.min(rect.height, rect.width);\n  const normalizedPositions = normalizePositions(targetMax, positions);\n  const tickRanges: ReadonlyArray<TickRange> = parseResult.rounds\n      .filter((r, index) => selectedRounds.has(index))\n      .map(r => [r.startTick, r.endTick]);\n  const alpha = alphas[parseResult.tickRate] || 0.2;\n  for (let [playerName, pps] of filterPositions(normalizedPositions, selectedPlayers, tickRanges).entries()) {\n    ctx.fillStyle = colorToString(getPlayerColor(allPlayers, playerName), alpha);\n    for (let pp of pps) {\n      ctx.fillRect(pp.p.x, targetMax - pp.p.y, 2, 2);\n    }\n  }\n}\n","import React from 'react';\nimport './App.scss';\nimport {Cmd, Dispatcher, just, Maybe, noCmd, nothing, Result, Sub, Task} from \"tea-cup-core\";\nimport {DevTools, Program, WindowEvents} from \"react-tea-cup\";\nimport {dim, Dim} from \"tea-pop-core\";\nimport {colorToString, drawPositions, getPlayerColor} from \"./DrawPositions\";\nimport {getPlayerNames, getPlayersInTeam, getTeams, parseDemo, ParseResult} from \"./Parser\";\n\ninterface Model {\n  readonly state: State;\n  readonly error: Maybe<Error>;\n}\n\ntype State =\n    | { tag: 'fresh', dragOver: boolean }\n    | { tag: 'parsing' }\n    | ReadyState\n\ninterface ReadyState {\n  tag: 'ready';\n  readonly canvasDimensions: Dim;\n  readonly parseResult: ParseResult;\n  readonly selectedPlayers: ReadonlySet<string>;\n  readonly selectedRounds: ReadonlySet<number>;\n}\n\ntype Msg =\n  | { tag: 'window-resized' }\n  | { tag: 'drag-over', over: boolean }\n  | { tag: 'got-canvas-dimensions', r: Result<Error, Dim> }\n  | { tag: 'file-dropped', file: Maybe<File> }\n  | { tag: 'got-parse-result', r: Result<Error, ParseResult> }\n  | { tag: 'got-draw-result', r: Result<Error, ParseResult> }\n  | { tag: 'toggle-player', player: string }\n  | { tag: 'toggle-round', index: number }\n\nconst windowResized: Msg = { tag: 'window-resized'}\n\nfunction gotCanvasDimensions(r: Result<Error,Dim>): Msg {\n  return { tag: \"got-canvas-dimensions\", r };\n}\n\nfunction init(): [Model, Cmd<Msg>] {\n  return noCmd(\n      {\n        state: { tag: \"fresh\", dragOver: false },\n        error: nothing,\n      }\n  );\n}\n\nconst canvasId = \"csgo-canvas\";\nconst canvasWrapperId = \"canvas-wrapper\";\n\nconst getCanvasDimensions: Task<Error, Dim> = Task.fromLambda(() => {\n  const c = document.getElementById(canvasWrapperId);\n  if (!c) {\n    throw new Error(\"canvas wrapper not found\");\n  }\n  const r = c.getBoundingClientRect();\n  return dim(r.width, r.height);\n})\n\nfunction view(dispatch: Dispatcher<Msg>, model: Model) {\n  return model.error\n    .map(e => (\n        <div className=\"fragalyzer error\">\n          <h1>Oooops</h1>\n          <pre>{e.message}</pre>\n        </div>\n    ))\n    .withDefaultSupply(() => {\n      const { state } = model;\n      switch (state.tag) {\n        case \"fresh\": {\n          return (\n              <div\n                  className=\"fragalyzer home\"\n                  onDragOver={(e) => {\n                    e.preventDefault();\n                  }}\n              >\n                <h1>CS:GO demo file analyzer</h1>\n                <p>\n                  <code>fragalyzer</code> is a tool that analyzes a .dem file and\n                  draws the paths of players.\n                </p>\n                <div\n                    className={`drop-zone${state.dragOver ? ' drop-over' : ''}`}\n                    onDragOver={(e) => {\n                      e.preventDefault();\n                      dispatch({\n                        tag: 'drag-over',\n                        over: true,\n                      })\n                    }}\n                    onDragLeave={() => {\n                      dispatch({\n                        tag: 'drag-over',\n                        over: false,\n                      })\n                    }}\n                    onDropCapture={e => {\n                      e.preventDefault();\n                      const msg: Msg = {\n                        tag: 'file-dropped',\n                        file: nothing\n                      };\n                      if (e.dataTransfer.files.length === 1) {\n                        const f = e.dataTransfer.files.item(0);\n                        if (f) {\n                          dispatch({\n                            ...msg,\n                            file: just(f)\n                          })\n                        } else {\n                          dispatch(msg)\n                        }\n                      } else {\n                        dispatch(msg);\n                      }\n                    }}\n                >\n                  Drop a .dem here get started\n                </div>\n              </div>\n          )\n        }\n        case \"parsing\": {\n          return <div className=\"fragalyzer parsing\"><p>Parsing demo file. It can take up to a few minutes...</p></div>\n        }\n        case \"ready\": {\n          const { parseResult, canvasDimensions } = state;\n          // const size = Math.min(canvasDimensions.w, canvasDimensions.h);\n          return (\n              <div className=\"fragalyzer ready\">\n                <div className=\"main\">\n                  <div id={canvasWrapperId} className=\"map-view\">\n                    {/*<div className=\"map-image\">*/}\n                    {/*  <img*/}\n                    {/*      height={size}*/}\n                    {/*      width={size}*/}\n                    {/*      src=\"./maps/mirage.png\"*/}\n                    {/*  />*/}\n                    {/*</div>*/}\n                    <canvas\n                        height={canvasDimensions.h}\n                        width={canvasDimensions.w}\n                        id={canvasId}\n                    />\n                  </div>\n                  <div className=\"right-panel\">\n                    <h2>Map</h2>\n                    <p>\n                      {state.parseResult.mapName}\n                    </p>\n                    {getTeams(parseResult).map(team => {\n                      const teamPlayers = getPlayersInTeam(parseResult, team).map(p => p.name);\n                      const allPlayers = getPlayerNames(parseResult);\n                      return (\n                          <div key={team} className=\"team\">\n                            <h2 className=\"team\">{team}</h2>\n                            <ul>\n                              {teamPlayers.map(player =>\n                                  <li key={player}>\n                                    <div className=\"player-color\" style={{\n                                      backgroundColor: colorToString(getPlayerColor(allPlayers, player), 1.0)\n                                    }}/>\n                                    <input\n                                        type=\"checkbox\"\n                                        name={player}\n                                        checked={state.selectedPlayers.has(player)}\n                                        onChange={e => dispatch({tag: 'toggle-player', player: player})}\n                                    />\n                                    {player}\n                                  </li>\n                              )}\n                            </ul>\n                          </div>\n                      );\n                    })}\n                  </div>\n                </div>\n                {viewTimeline(dispatch, parseResult, state.selectedRounds)}\n              </div>\n          );\n        }\n      }\n    })\n}\n\nfunction update(msg: Msg, model: Model): [Model, Cmd<Msg>] {\n  switch (msg.tag) {\n    case \"window-resized\": {\n      return ifReady(model, () => {\n        return [model, Task.attempt(getCanvasDimensions, gotCanvasDimensions)];\n      });\n    }\n    case \"drag-over\": {\n      if (model.state.tag === \"fresh\") {\n        return noCmd({\n          ...model,\n          state: {\n            tag: 'fresh',\n            dragOver: true\n          }\n        })\n      }\n      return noCmd(model);\n    }\n    case \"got-canvas-dimensions\": {\n      return msg.r.match(\n          canvasDimensions => {\n            return ifReady(model, state => {\n              const newModel: Model = {\n                ...model,\n                state: {\n                  ...state,\n                  canvasDimensions,\n                }\n              };\n              return [\n                newModel,\n                draw(newModel)\n              ]\n            });\n          },\n          err => noCmd({...model, error: just(err)})\n      )\n    }\n    case \"file-dropped\": {\n      return msg.file\n          .map<[Model, Cmd<Msg>]>(f => {\n            const newModel: Model = {\n              ...model,\n              state: {\n                tag: 'parsing'\n              }\n            };\n            const t: Task<Error, ParseResult> = Task.fromPromise(() =>\n              parseDemo(f)\n            );\n            const cmd: Cmd<Msg> =\n                Task.attempt(\n                    t,\n                  r => ({ tag: \"got-parse-result\", r })\n                )\n            return [newModel, cmd];\n          })\n          .withDefaultSupply(() => noCmd({\n            ...model,\n            state: {\n              tag: 'fresh',\n              dragOver: false,\n            }\n          }));\n    }\n    case \"got-parse-result\": {\n      return msg.r.match(\n          parseResult => {\n            const selectedPlayers: ReadonlySet<string> = new Set(parseResult.players.map(p => p.name));\n            const newModel: Model = {\n              ...model,\n              state: {\n                tag: \"ready\",\n                parseResult,\n                selectedPlayers,\n                canvasDimensions: Dim.zero,\n                selectedRounds: new Set(parseResult.rounds.map((r, index) => index)),\n              }\n            };\n            return [newModel, Task.attempt(getCanvasDimensions, gotCanvasDimensions)];\n          },\n          err => noCmd({...model, error: just(err)})\n      )\n\n\n    }\n    case \"got-draw-result\": {\n      console.log(\"draw res\");\n      return noCmd(model);\n    }\n    case \"toggle-player\": {\n      return ifReady(model, state => {\n        const { selectedPlayers } = state;\n        const spa: string[] = selectedPlayers.has(msg.player)\n            ? Array.from(selectedPlayers).filter(x => x !== msg.player)\n            : [...Array.from(selectedPlayers), msg.player];\n        const newModel: Model = setState(model, {\n          ...state,\n          selectedPlayers: new Set(spa)\n        });\n        return [newModel, draw(newModel)];\n      })\n    }\n    case \"toggle-round\": {\n      return ifReady(model, state => {\n        const { selectedRounds } = state;\n        const a = Array.from(selectedRounds);\n        const newSelRounds = new Set(\n            selectedRounds.has(msg.index)\n              ? a.filter(x => x !== msg.index)\n              : [...a, msg.index]\n        );\n        const newModel: Model = setState(model, {\n          ...state,\n          selectedRounds: newSelRounds\n        });\n        return [newModel, draw(newModel)];\n      })\n    }\n  }\n}\n\nfunction ifReady(model: Model, f:(state: ReadyState) => [Model, Cmd<Msg>]): [Model, Cmd<Msg>] {\n  if (model.state.tag === 'ready') {\n    return f(model.state);\n  }\n  return noCmd(model)\n}\n\nfunction setState(model: Model, state: State): Model {\n  return {\n    ...model, state\n  }\n}\n\nfunction draw(model: Model): Cmd<Msg> {\n  if (model.state.tag === \"ready\") {\n    const { selectedPlayers, parseResult, selectedRounds } = model.state;\n    return drawIntoCanvas(parseResult, selectedPlayers, selectedRounds)\n  }\n  return Cmd.none();\n}\n\nfunction drawIntoCanvas(parseResult: ParseResult, selectedPlayers: ReadonlySet<string>, selectedRounds: ReadonlySet<number>): Cmd<Msg> {\n  const t: Task<Error, ParseResult> = Task.fromLambda(() => {\n    const canvas = document.getElementById(canvasId) as HTMLCanvasElement;\n    if (!canvas) {\n      throw new Error(\"canvas not found !\");\n    }\n    drawPositions(canvas, parseResult, selectedPlayers, selectedRounds);\n    return parseResult;\n  });\n  return Task.attempt(t, r => ({\n    tag: 'got-draw-result',\n    r\n  }))\n}\n\nconst windowEvents = new WindowEvents();\n\nfunction subscriptions(model: Model): Sub<Msg> {\n  return windowEvents.on('resize', () => windowResized)\n}\n\n\nfunction viewTimeline(dispatch: Dispatcher<Msg>, parseResult: ParseResult, selectedRounds: ReadonlySet<number>) {\n  return (\n    <div className=\"timeline\">\n      {parseResult.rounds.map((round, index) => {\n        const selected = selectedRounds.has(index);\n        const className = `round${selected ? ' selected' : ''}`;\n        return (\n            <div\n                className={className}\n                key={index}\n                onClick={() => dispatch({tag: 'toggle-round', index})}\n            >\n              {(index + 1) + \" : \" + round.scoreCT + \"/\" + round.scoreT}\n            </div>\n        )\n      })}\n    </div>\n  );\n}\n\nfunction App() {\n  return (\n      <Program\n          init={init}\n          view={view}\n          update={update}\n          subscriptions={subscriptions}\n          devTools={DevTools.init<Model, Msg>(window)}\n      />\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}